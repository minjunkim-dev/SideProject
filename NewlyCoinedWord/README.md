# NewlyCoinedWord
### 개발환경 : <img src ="https://img.shields.io/badge/Swift-5.5-FA7343?logo=swift&logoColor=white"> <img src="https://img.shields.io/badge/Xcode-13.3-1575F9?logo=Xcode&logoColor=white"> <img src="https://img.shields.io/badge/Platforms-iOS_13.0-Green?style=flat-square">
> 네이버 사전 검색 API를 활용하여 신조어를 검색하는 기능의 화면 구현해보기

* 다국어 지원: 영어, 한국어
* 라이트/다크모드 모두 동일한 테마로만 지원
* 세로/가로모드 모두 지원

## 기술스택
> SnapKit, Then, MVVM pattern, Alamofire, JGProgresseHUD, Localization, UserDefaults, propertyWrapper, NotificationCenter, Network, UICollectionView, UIAlert, delegate pattern

## 이슈 및 해결방법
> 1. 세로/가로모드에 대한 UI 대응 방법
  - UIDevice.current.orientation 의 경우 첫 화면이 등장하기 전까지는 unknown 값을 반환함을 확인함
  - 따라서, 첫 화면을 구성할 때는 UIApplication.shared.windows.first?.windowScene?.interfaceOrientation 을 통해 디바이스 방향을 확인하고,
첫 화면 이후 화면 전환에서는 UIDevice.current.orientation 을 통해 디바이스 방향 확인 및 화면 전환에 따른 UI 재구성을 실행함

> 2. 해시태그를 무엇으로 표현할 것인가
  - 처음에는 간단하게 표현하기 위해 UIStackView를 고려했으나 해시태그 버튼의 수가 늘어나거나 해시태그 내의 텍스트가 길어질 경우,
한 라인 안에 다 들어오지 못하는 경우가 발생할 수 있어 스택뷰로는 이러한 유동적인 변화에 대처하기 어렵다고 판단함
  - 스택뷰 대신 UICollectionView를 활용하되 해시태그의 텍스트에 따라 셀의 크기가 변해야하므로
UICollectionViewFlowLayout의 estimateItemSize 프로퍼티를 automaticSize로 설정하여 self-sizeing cell을 구현함
  - 이 때 발생한 문제점은 minimumInterItemSpacing 프로퍼티를 설정하여 셀 간의 간격을 분명히 설정하였음에도 불구하고 동작하지 않음
  - 이를 해결하기 위해 UICollectionViewFlowLayout을 상속받은 클래스로 layoutAttributesForElements 메서드를 오버라이딩하여
셀들을 좌측 정렬하되, 원하는 간격만큼 패딩을 직접 주어 설정함

> 3. 신조어 리스트를 어디서, 어떻게 관리할 것인가
  - 손쉽게 하려면 직접 신조어 리스트를 몇개 가져와서 이를 파일로 별도로 관리하고, 이 파일에 있는 신조어 리스트를 가져와 활용하면 되지만 좀 더 배우기 위해 API를 활용함
(원래는 네이버 오픈 사전에 있는 신조어 사전을 크롤링하여 신조어 리스트를 가져오려고 했으나, 네이버의 경우 크롤링을 막아둔듯 함, 계속 루트 페이지의 html만 가져옴)
  - 네이버 오픈 API에서 제공하는 사전 검색 API를 활용해 신조어 리스트를 가져오되,
사전에 신조어 목차가 별도로 있는 것이 아니어서 "신조어"를 검색한 결과에서 추려서 신조어 리스트를 별도로 생성해야 함
  - 그러나 사전에 정해진 양식이 있는 것이 아니라 신조어 리스트를 정확하게 만들기가 쉽지 않다는 한계가 존재함(즉, 신조어로 판단할 완벽한 필터링 조건을 설정하기가 매우 어려움)

> 4. html 태그 삭제 방법
  - API를 통해 가져온 텍스트를 확인해보니 <b>, </b>와 같은 html 태그가 종종 포함되어 있음을 확인함
  - html 태그를 제거하기 위해 관련 기능을 extension "String"에서 연산 프로퍼티로 정의하고 활용함

> 5. 효율적인 API 호출에 대한 고려
  - 이 앱은 네이버 사전에서 단순히 단어를 검색하는 것이 아니라, 신조어 리스트에서 신조어를 검색 가능하게끔 해야하므로 신조어 리스트를 먼저 구성하는 것이 필수적임
  - 사전 특성상 데이터 변화가 많이 없기 때문에 중복 데이터 노출 염려가 거의 없다고 판단하여 "오프셋 기반 페이지네이션"으로 API 호출을 여러번하여
"신조어"라는 단어에 대한 검색 리스트를 가져오고, 여기서 필터링을 통해 신조어 리스트를 별도로 만듦
  - 이 때 주의할 점은 여러번의 API 호출 결과를 최종적으로 합쳐야 한다는 것임. 프로젝트를 진행하다가 이를 놓침.
  - 단, Alamofire를 활용해 API 호출을 진행하여 기본적으로 async로 동작하지만, main 큐(serial하게 동작)에서 동작시켰기 때문에 API Call이 많아질수록 시간이 오래 걸린다는 이슈가 존재함
  - 그래서 API 호출을 global 큐(concurrent하게 동작)에서 동작하게 하여 API 호출 시간을 줄이려고 함
  - 한번 신조어 리스트를 구성하고 나면 그 이후부터는 API 호출을 하지 않도록 했는데,
그 이유는 매번 하면 시간이 너무 오래 걸리기도 하고, 사전 특성상 데이터가 자주 변화하지 않기 때문임
  - 따라서 API 호출로 신조어 리스트를 UserDefaults에 저장하면, 그 이후로는 UserDefaults 값을 확인하여 있다면 API 호출은 하지 않고 해당 리스트를 그대로 사용하도록 함

> 6. 사용자의 대기가 필요할 때 적절한 UX 처리
  - 신조어 리스트를 가져올 때, 그리고 신조어를 검색할 때 사용자에게 대기 시간이 필요한데 이 때 적절한 UX 처리가 필요하여 Progress HUD를 보여줌
  - 신조어 리스트가 없는데 단어를 검색하거나, 단어를 검색하고 있는데 다시 검색하려고 하는 경우를 방지하기 위해 HUD가 띄워진 경우에는 입력이 되지 않도록 방지함

> 7. 고차함수의 활용
  - API 호출에 성공하면 그 결과를 적절히 필터링하고 이를 실제로 사용할 신조어 리스트로 변환하는 작업이 필요한데,
이 때 forEach를 사용했던 것을 map 고차함수로 변경함
  - 변경한 이유는 고차함수가 좀 더 성능이 좋다고 알고 있음..

> 8. 텍스트 길이에 따른 폰트 크기 조정의 필요성
  - 신조어 의미의 텍스트 길이는 미리 알 수 없으므로 설정해둔 높이 내에서 유동적인 폰트 크기가 가능하고, 여러줄로 표현 가능하게 함.

> 9. Cell의 init() 메서드 호출 시기에 대한 고민
  - 컬렉션 뷰가 reloadData 메서드를 호출 할때마다 컬렉션 뷰 셀 내의 버튼에 addTarget을 호출하고 있음을 확인함
  - 이러한 불필요한 중복 호출을 방지하기 위해 addTarget 구문을 init 메서드에 호출하여 방지함
  - 셀의 init 메서드의 경우 최초 한번만 실행되고, 그 이후의 reloadData 메서드 호출은 셀을 재사용하므로 init 메서드가 호출되지 않는 것으로 추정됨

> 10. 네트워크 체크 기능의 필요성
  - 신조어 리스트 구성을 위해서는 API 호출을 먼저 해야하므로 네트워크가 필수적이므로, 네트워크 체크 기능이 필요하다고 판단함
  - 네트워크가 필요한 경우에는 alert을 띄워주되 설정을 확인할 수 있도록 iOS 설정 페이지로 넘어갈 수 있는 기능까지 추가함
  - viewWillAppear에서 네트워크 체크를 시작하고, viewWillDisappear에서 네트워크를 중지하도록 하며,
네트워크 상태 변화를 감지할 때마다 신조어 리스트가 아직 구성되지 않은 상태이면서 네트워크가 연결된 상태라면 notification을 보내도록 하고,
이 notification을 받았을 때 API 호출을 통해 신조어 리스트를 가져오도록 구현함

> 11. 구조체 간의 간단한 비교를 위한 == 연산자 오버로딩?
  - 신조어 리스트에 사용자가 검색한 단어가 있는지 확인하기 위해 신조어를 의미하는 구조체를 비교하는 로직이 필요했는데,
이를 구조체 간 프로퍼티 값이 모두 동일한지 여부로 직접 확인하다가 불편한 것 같아 구조체끼리 간단하게 비교할 수 있도록 == 연산자 오버로딩을 구현함
  - extension을 통해 Equatable 프로토콜을 채택하고, == 연산자를 오버로딩함

> 12. 셀의 높이가 텍스트 길이에 따라 변경되는 이슈 발생
  - 해시태그 갱신시에 각 셀이 텍스트 길이에 따라 높이가 변경되는 이슈를 발견함
  - 컬렉션 뷰의 셀을 self-sizing 셀로 구성하여 발생한 이슈로 이 앱의 해시태그의 경우 height는 고정되고 width를 유동적이면 되므로,
컬렉션 뷰 셀의 contentView의 높이를 특정 값으로 고정시켜서 문제를 해결함

> 13. API 호출의 성공 판단 기준은?
  - 오프셋 기반 페이지네이션을 통해 API를 여러번 호출하는데 상황에 따라 일부 API 호출은 실패하는 경우도 있을 수 있음
  - 따라서, 여러번의 API 호출이 모두 성공했을 때만 API 호출이 최종적으로 성공했다고 판단하기로 함

> 14. propertyWrapper를 활용한 커스텀 UserDefaults 활용중 발생한 문제
  - 신조어 리스트를 저장 및 관리하기 위해 UserDefaults를 사용하였는데, 커스텀 자료형에 대해서는 get, set 연산이 정상적으로 동작하나
오히려 기본 자료형에 대해서는 정상적으로 동작하지 않는 경우를 확인함
  - PropertyList encoder, decoder 를 JSON encode, decoder로 변경하고 예외처리를 명확하게 하여 이슈를 해결함

> 15. 신조어 리스트를 구성하고 나면, 정말 갱신이 필요가 없을까?
  - 사전 특성상 데이터 변화가 느리기 때문에 신조어 리스트를 매번 새로 구성할 필요가 없다고 생각함
  - 그러나, 이 앱을 오래 사용하게 된다면 분명히 갱신이 필요한 시점이 반드시 찾아오게 되어있음
  - 이를 해결하기 위해 앱을 켰을 때 해당 날짜가 매달 1일인지 여부를 먼저 확인하고,
매달 1일이면서 오늘 아직 신조어 리스트를 갱신하지 않았다면 신조어 리스트를 API 호출을 통해 새로 가져오도록 함
  - 오늘 업데이트 했는지 여부를 확인하기 위해 UserDefaults를 활용함

> 15. iOS 버전에 따른 UI 차이?
  - 앱을 완성했다고 생각하고 iOS 13 시뮬레이터로 실행시켜보니 검색 역할을 담당하는 UITextField의 UI가 원하는대로 보이지 않음을 확인함
  - 텍스트필드의 테두리도 보이지 않고 텍스트 필드의 영역도 원하는대로 잡혀있지 않았음
  - iOS 버전 별로 코드를 분기하여 작성한 것도 아니고, 관련 코드를 아예 작성하지 않았음을 이때서야 확인함
  - 놀랍게도 iOS 15에서는 위에서 언급한 것들을 알아서 처리해주었음(아직도 그 이유를 모르겠음..)
  - 앱을 테스트할 때는 항상 여러 iOS 버전과 라이트/다크모드, 디바이스 방향에 따라 다양하게 테스트 해야할 필요성을 느낌

> 16. API 사용을 위해 필요한 정보와 관련된 상수를 별도로 관리할 필요성
  - 네이버 오픈 API 사용을 위해 클라이언트 ID, Secret이 필요한데 이를 Constanst.swift에 별도로 관리함
  - 그런데 이 파일을 레포지토리에 push 해버림(하면 안되는거 알았는데..)
  - 항상 보안에 신경쓰고 필요하다면 .gitignore에 등록해두는 것을 잊지말기로 함
  
